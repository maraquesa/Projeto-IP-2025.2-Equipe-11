import math
import pygame
from operações import calcular_velocidade_diagonal

class Perssonagem(pygame.sprite.Sprite) :

    def __init__(self, velocidade : int, posicao_inicial : tuple[int, int]) :
        super().__init__()

        self.imagem = pygame.Surface((20,20))#mudar
        self.imagem.fill('Green')
        self.retangulo = self.imagem.get_rect(midbottom=(posicao_inicial[0], posicao_inicial[1]))
        self.velocidade = velocidade
        self.delay_x = 0
        self.delay_y = 0



    def atualizar(self,tela) :
        tela.blit(self.imagem, self.retangulo)
        tecla = pygame.key.get_pressed()
        tecla_a = True if tecla[pygame.K_a] else False
        tecla_d = True if tecla[pygame.K_d] else False
        tecla_w = True if tecla[pygame.K_w] else False
        tecla_s = True if tecla[pygame.K_s] else False

        #movimento
        if tecla_a :
            if tecla_s or tecla_w : self.alterar_x(calcular_velocidade_diagonal(-self.velocidade))
            else : self.alterar_x(-self.velocidade)

        if tecla_d :
            if tecla_s or tecla_w : self.alterar_x(calcular_velocidade_diagonal(self.velocidade))
            else : self.alterar_x(self.velocidade)

        if tecla_s :
            if tecla_a or tecla_d : self.alterar_y(calcular_velocidade_diagonal(self.velocidade))
            else : self.alterar_y(self.velocidade)

        if tecla_w :
            if tecla_a or tecla_d : self.alterar_y(calcular_velocidade_diagonal(-self.velocidade))
            else : self.alterar_y(-self.velocidade)


    
    '''funções que execultam o movimento, a maior parte é para resolver o proplema do objeto se mover mais rapido ou lento na diagonal,
        como o pygame não conssegue mover um objeto em numero decimais, o progama ele sempre arredondara o movimento para cima, toda vez que 
        o progama execultar um movimento que foi maior que o recebido, ele coloca uma "divida" no progama, e o perssonagem não conssiguira se 
        ate a divida ser paga, se o perssonagem tiver uma divida de movimento, ao invez do movimento ser usado para mover o perssonagem,
        o movimento sera utilizado para pagar a divida.'''
    def alterar_x(self, valor : float) :
        if self.delay_x <= 0 :
            self.retangulo.x += math.ceil(valor) if valor >= 0 else math.floor(valor)
            self.delay_x += abs(valor) - int(abs(valor))
        else :
            self.delay_x -= abs(valor)
        print(self.delay_x)
    def alterar_y(self, valor : float) :
        if self.delay_y <= 0 :
            self.retangulo.y += math.ceil(valor) if valor >= 0 else math.floor(valor)
            self.delay_y += abs(valor) - int(abs(valor))
        else :
            self.delay_y -= abs(valor)
